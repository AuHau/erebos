// @flow

import EthAPI, { type EthTransactionReceipt } from '@erebos/api-eth'
import { type ABI } from '@erebos/eth-abi'

type ContractParams = {
  eth: EthAPI,
}

// TODO: should probably implement or at least contain EthLog, but also the decoded fields
type ContractEvent = {}

// TODO: differentiate "runtime" contracts (methods and events or ABI injected at runtime)
// from "compiled" ones generated by the CLI?
// Maybe the base/abstract class simply handles the runtime dependency injection (Eth API)
// and the "runtime" constract handles additional params such as methods and events or ABI

export class Contract {
  _eth: EthAPI

  constructor(params: ContractParams) {
    this._eth = params.eth
  }

  // constant methods return the value (is it always at most one output?)

  observe(eventName: string, params: any): Observable<ContractEvent> {}
  when(eventName: string, params: any): Promise<ContractEvent> {
    // subscribe and resolve on first value
  }
}

class TransactionResult {
  receipt: EthTransactionReceipt
  wait(confirmations: number): Promise<EthTransactionReceipt> {}
  observe(): Observable<EthTransactionReceipt> {}
}

// Contract factory takes in an ABI and returns a Contract class
// Contract class should have "view" functions as "get<name>()" returning a Promise of the result value (can it be more than one output?)
// Mutation functions should return a TransactionResult instance

const buildContract = (abi: ABI): Class<Contract> => {
  const cls = class extends Contract {}

  // TODO interate through ABI to generate methods and cache events
  cls.prototype.getName = function() {
    return 'test'
  }

  return cls
}
